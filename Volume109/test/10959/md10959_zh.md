### 🌏 **Language**
| zh [中文](md10959_zh.md) | en [English](md10959_en.md) | 
| [C++](UVa10959.cpp) |


<aside>

## **UVa 10959 - The Party, Part I**

Don Giovanni 喜歡跳舞——尤其是和女孩們跳舞！派對上的每個人都很享受跳舞。能夠和主人（即 Don Giovanni）跳舞是最大的樂趣；如果不能，和曾經或將要和主人跳舞的人跳舞是第二大的榮譽。這種榮譽可以傳遞給其他人。定義一個人的 Giovanni 數如下，在派對結束後，誰和誰跳過舞是完全已知且固定的：

1. 沒有人有相同的數字。
2. Don Giovanni 的數字是 0。
3. 如果一個人沒有和 Giovanni 本人跳舞，但和 Giovanni 數為 n 的人跳過舞，且沒有和 Giovanni 數小於 n 的人跳過舞，那麼這個人的 Giovanni 數是 n+1。
4. 如果一個人的 Giovanni 數無法從上述規則中確定（他/她沒有和任何具有有限 Giovanni 數的人跳過舞），那麼他/她的 Giovanni 數是 ∞。幸運的是，在這個問題中你不需要這條規則。

你的任務是編寫一個程式來計算 Giovanni 數。

---

### **輸入**

輸入以一個正整數開始，表示接下來的測試案例數量。這行之後是一個空行，並且在兩個連續的輸入之間也有一個空行。

第一行有兩個數字 P 和 D；這表示派對上有 P 個人（包括 Don Giovanni）和 D 對舞伴（P ≤ 1000 且 D ≤ P(P−1)/2）。接下來的 D 行，每行包含兩個不同的人，表示這兩個人跳過舞。人用 0 到 P−1 之間的數字表示；Don Giovanni 用 0 表示。

如前所述，我們設計輸入使得你不需要在計算 Giovanni 數時使用 ∞ 規則。我們已經盡最大努力消除列出舞伴時的重複，例如，如果在 D 行中有一行 "4 7"，那麼這是唯一出現的 "4 7"，且沒有出現 "7 4"。但萬一你看到重複，你可以忽略它（忽略重複的，而不是第一次出現的）。

### **輸出**

對於每個測試案例，輸出必須符合以下描述。輸出將與測試案例一致，並由空行分隔。

輸出 P−1 行。第 i 行是人 i 的 Giovanni 數，對於 1 ≤ i ≤ P−1。注意，這是 P−1 因為我們在輸出中跳過 Don Giovanni。

---

</aside>

### 解法
<aside>

    以 Don Giovanni (0號) 作為 BFS 起點。

    遍歷隊列，更新每個參與者的最短距離。

    從隊列中取出當前節點 cur，並檢查其所有鄰居 nxt

    如果尚未訪問，則更新其距離並將其加入隊列
</aside>
