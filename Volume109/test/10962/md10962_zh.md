### 🌏 **Language**
| zh [中文](md10962_zh.md) | en [English](md10962_en.md) | 
| [C++](UVa10962.cpp) |


<aside>

## **UVa 10962 - Don Giovanni's Last Dinner**

Don Giovanni吃大量的菜——很多。Leporello 忍不住垂涎三尺。每當Don Giovanni放棄一道菜時，Leporello 就有機會：他可以在主人背後吃掉剩下的食物，並且他肯定會立即開始吃。但他是僕人，必須回答主人的要求。如果主人問他問題時他滿嘴食物，那將是很尷尬的。

編寫一個程式來確定每次呼叫 Leporello 時，Leporello 是否滿嘴食物。

---

### **輸入**

輸入以一個正整數開始，表示接下來的測試案例數量。這行之後是一個空行，並且在兩個連續的輸入之間也有一個空行。

輸入的第一行包含唐喬凡尼的進食速度 R，Leporello 的進食速度 r，菜的數量 N 和呼叫的次數 C。

接下來有 N 行，每行代表一道菜。每行包含兩個數字 s 和 g，其中 s > g > 0：s 是菜上的食物量，g 是唐喬凡尼消耗的食物量。唐喬凡尼將按這些 n 行給出的順序依次吃這些菜。唐喬凡尼一停止吃一道菜，就把它交給 Leporello，然後立即開始下一道菜。Leporello 只要有食物就會吃，並且他也按順序吃這些菜。

接下來有 C 行，每行代表一次呼叫。每行包含一個數字 t，表示唐喬凡尼呼叫 Leporello 的時間。（令人驚訝的是，這些呼叫並不會減慢唐喬凡尼的進食速度。）呼叫時間序列是遞增的。

所有輸入數字都是正整數，且最多為 2000。

### **輸出**

對於每個測試案例，輸出必須符合以下描述。兩個連續案例的輸出之間用空行分隔。

對於每次呼叫，輸出一行：

- 如果 Leporello 在呼叫時正在吃，輸出 `full`；
- 否則輸出 `clear`。

邊界情況：如果 Leporello 正好在呼叫時開始或停止吃，例如，他在 20 時收到食物，在 40 時吃完，並且在這兩個時間點都被呼叫。在這兩種情況下，答案都是 `full`。（這也很好地處理了他在 35 時吃完一道菜，在 35 時收到另一道菜，並在 35 時被呼叫的情況。）

---

</aside>

### 解法
<aside>

    totalEatTime：Don Giovanni 吃完前 i 道菜的總時間
    startTime：Leporello 開始吃第 i 道菜的時間。
    endTime：Leporello 吃完第 i 道菜的時間。

    檢查呼叫時間 callT 是否在 Leporello 吃某道菜範圍內  
</aside>
