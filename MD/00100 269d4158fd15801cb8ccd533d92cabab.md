# 00100

解決方案: 3N+1（Collatz猜想）
選取: 完成

Link： https://vjudge.net/problem/UVA-100

---

## Problem

- 目標
    
    <aside>
    
    數字從區間[i, j]經過「3n+1算法」生成的序列長度，找出最大值
    
    </aside>
    
- 中文
    
    <aside>
    
    ## 3n + 1 問題 (The 3n + 1 problem)
    
    在電腦科學中，許多問題被分類到不同的問題類別（例如 NP、不可解、遞迴）。在這個問題中，你將分析一個演算法的性質，而這個演算法對所有可能輸入的分類目前尚未確定。
    
    考慮以下演算法：
    
    ```
    input n
    print n
    if n = 1 then STOP
      if n is odd then n ← 3n + 1
      else n ← n / 2
    GOTO 2
    
    ```
    
    給定輸入 (n = 22)，將會輸出以下數列：
    
    ```
    22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
    
    ```
    
    目前的猜想是：對任何整數輸入值，該演算法最終都會停止（當輸出 1 時）。雖然演算法看似簡單，但這個猜想是否正確仍未知。不過，已經驗證了所有 (0 < n < 1,000,000) 的整數（甚至更多）。
    
    對於一個輸入 (n)，可以計算在輸出 1 之前（包含 1）所輸出的數字個數，這稱為 **cycle-length**。例如，22 的 cycle-length 為 16。
    
    現在，對於任意兩個整數 (i) 和 (j)，你需要計算在區間 ([i, j])（包含端點）內所有整數的最大 cycle-length。
    
    ---
    
    📥 輸入
    
    - 輸入由一系列整數對 (i, j) 組成，每行一對。
    - 所有整數滿足 (0 < i, j < 10,000)。
    - 你需要處理所有輸入對，並對每一對計算區間內的最大 cycle-length。
    - 保證不會發生超過 32 位元整數的溢位。
    
    📤 輸出
    
    - 對每一對 (i, j)，輸出三個數字：
        1. (i)
        2. (j)
        3. 在區間 ([i, j]) 內的最大 cycle-length。
    - 三個數字之間至少以一個空格分隔，並且每組輸出獨立一行。
    - 輸出的 (i, j) 必須保持與輸入相同的順序。
    
    ---
    
    - Sample
        
        範例輸入
        
        ```
        1 10
        100 200
        201 210
        900 1000
        
        ```
        
        範例輸出
        
        ```
        1 10 20
        100 200 125
        201 210 89
        900 1000 174
        
        ```
        
    </aside>
    
- 資源

## Solution

<aside>

[3N + 1](https://www.notion.so/3n-1-Collatz-Conjecture-269d4158fd1580b8becdf6450aecf12d?pvs=21)

</aside>

## Code

- code_01
    
    ```cpp
    /*
     * Problem: "UVa 100 - The 3n+1 problem"
     *  Author: "Jia_coding"
     *
     *     Tag: 數學(Math), 遞迴(Recursion), Collatz猜想(3n+1)
     */
    
    #include <bits/stdc++.h>
    using namespace std;
    
    int cycle_len(int n, int cnt) {
        if (n == 1) return cnt;
    
        if (n % 2) return cycle_len(3 * n + 1, cnt + 1);
        else       return cycle_len(n / 2, cnt + 1);
    }
    
    int main() {
        int a, b;
        while (cin >> a >> b) {
            int maxlen = 0;
            for (int i = min(a, b); i <= max(a, b); i++) {
                int cnt = 1;
                maxlen = max(maxlen, cycle_len(i, cnt));
            }
            printf("%d %d %d\n", a, b, maxlen);
        }
        return 0;
    }
    
    ```