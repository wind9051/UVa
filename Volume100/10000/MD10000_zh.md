### 🌏 **Language**
| zh [中文](MD10000_zh.md) | en [English](md10000_en.md) | 
| [C++](UVa10000.cpp) |


<aside>

## **UVa 10000 - Longest Paths**

眾所周知，有些人的社交能力並未完全發揮。一個例子是缺乏計算距離和時間間隔的天賦。這導致一些人總是選擇最長的路線從一個地方到另一個地方，結果是他們無論有什麼約會都會遲到，包括婚禮和程式設計比賽。這對他們的朋友來說可能非常煩人。

凱撒就有這樣的問題。當他必須從一個地方走到另一個地方時，他意識到他必須拜訪很多人，因此總是選擇最長的路徑。凱撒的一位朋友費利佩已經了解問題的本質。費利佩認為，在電腦的幫助下，他或許能夠計算凱撒到達目的地所需的時間。這樣他就可以把時間花在比等待凱撒更愉快的事情上。

您的目標是幫助 Felipe 開發一個程序，**計算可以從給定起點（凱撒的住所）在給定圖中構建的最長路徑的長度**。您可以假設從該起點到任意目的地至少有一條路徑。此外，該圖沒有循環（沒有從任何節點到其自身的路徑），因此凱撒將在有限的時間內到達他的目的地。依照同樣的推理思路，節點不被視為直接與其自身相連。

---

### **輸入**

輸入由多個案例組成。每個案例的第一行包含一個正數 n (1 < n ≤ 100)，指定 C´esar 可能存取的點的數量（即圖中的節點數量）。 n = 0 的值表示輸入結束。之後，提供第二個數字 s，表示凱撒旅程的起點 (1 ≤ s ≤ n)。然後，您將獲得一個位置對 p 和 q 的列表，每行一對，每行上的位置以空格分隔。 「p q」對錶示 C´esar 可以在 p 之後存取 q。一對零（‘0 0’）表示案例的結束。如前所述，您可以假設提供的圖不是循環的，並且每個位置都可以從起始位置到達。

### **輸出**

對於每個測試案例，您必須找到從起始位置開始的最長路徑的長度。您還必須列印最長路徑的最後位置的編號。如果有多個最大長度的路徑，則列印編號最小的最後位置。
每個測試案例後列印一個新行。

---

</aside>

### **解法**

<aside>

> [!TIP]
> 
> **從起點出發的「最長路徑」**，**有向無環圖（DAG, Directed Acyclic Graph）**
> 
> **Floyd-Warshall 演算法**：
>     - 使用三重迴圈更新圖 G 中的最短路徑。
>     - 對於每個中繼點 k，更新所有節點對 `(i, j)` 的最短路徑 G[i][j]。
> **尋找最長路徑**：
>     - 初始化 max_len 為 0，to 為 0。
>     - 遍歷所有節點，找到從起始節點 s 出發的最長路徑，更新 max_len 和 to。
> 

</aside>