UVA13300

2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 14
H: Ghost HuntingSource file name: hunting.c, hunting.cpp, hunting.java, or hunting.py
Author: Germán Sotelo
A ghost Pokemon gang has been playing pranks on citizens and damaging public property in Lavender City. Any
attempt to apprehend the gang has been futile, since it is impossible to see a ghost with the naked eye.
The major of Lavender City requested help from Silph Corp. After several months of research, the corporation
developed a system that allows people to see the ghost Pokemon. The system is based on beacons: when a ghost
Pokemon is surrounded by them, it is visible to anyone. However, the beacons use a lot of energy and thus
require to be installed in light poles already available in the city. A Pokemon is surrounded by beacons if, in
order to leave town, it needs to cross through a virtual fence: the idea is that any pair of beacons induce a virtual
fence defined by the segment of a straight line starting at one of them and ending at the other one.
The past week, Silph Corp sent a truck full of beacons to create a visibility area in Lavender City. However, the
ghost gang attacked the truck and damaged most of the beacons, except for three that are still fully operational.
Since the production of beacons takes time, and the situation is getting dangerous by the day, the major wants to
find the largest possible area that can be set up to see the ghosts once the three beacons are installed.
Given the location of the light poles, your help has been requested to find such an area.
Input
The input consists of several test cases. Each test case begins with a line containing an integer N (3 ≤ N ≤2×103)
representing the number of light poles in Lavender City. Each of the following N lines contains two blank-
separated integers x and y (−106 <x,y <106) indicating the location (x,y) of a light pole.
The input must be read from standard input.
Output
For each test case, output a single line with the largest possible area, truncated to one decimal, where the ghosts
can be seen.
The output must be written to standard output.
2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 15
Sample Input
4
-1 -1
-1 1
1 -1
1 1
3
-1 -1
-1 3
3 3
4
1 1
2 1
4 1
4 6
Sample Output
2.0
8.0
7.5

-----------------------------------------------------------------------------------------------------------------------------

UVA13301

2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 16
I: Impossible CommunicationSource file name: impossible.c, impossible.cpp, impossible.java, or impossible.py
Author: Rafael García
At your home university there are N research groups and M procedures to exchange information between them.
Some procedures enable information to be sent from a specific group to another group. Other procedures are
designed to share information between two or more groups (in either direction for each pair of them).
To be more precise, the research system of your university uses the following notation to identify the information
sharing procedures:
• A simple procedure that enables information to be sent from the group I to the group J is specified as
1 I J
• A complex procedure that enables bi-directional information sharing between the k groups I1, I2, ..., Ik is
described as
k I1 I2 ··· Ik
The president of your home university wants to make sure that the procedures to exchange information between
research groups are sufficiently complete: he wants to make sure that any research group is able to send
information to any other group (regardless of whether it is done directly or using intermediaries).
Please, help your president!
Input
The input consists of several test cases. The first line of a case contains two integers N and M indicating,
respectively, the number of research groups (2 ≤ N ≤50 000) and the number of information sharing procedures
(1 ≤ M ≤ 1 000). Each of the next M lines identifies one simple or one complex procedure, following the
above-described notation. Research groups are represented with the integers 1,2,...,N. You can assume that
each complex procedure has at most 1 000 research groups. Single blanks are used to separate any pair of
consecutive numbers.
The input must be read from standard input.
Output
For each test case output a single line with YES if the given set of procedures is sufficiently complete and NO
otherwise.
The output must be written to standard output.
2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 17
Sample Input
3 3
1 1 2
1 2 3
1 1 3
4 3
1 1 2
1 2 3
3 1 3 4
Sample Output
NO
YES

-----------------------------------------------------------------------------------------------------------------------------

UVA13302

2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 18
J: Jawbreaking CandySource file name: jawbreaking.c, jawbreaking.cpp, jawbreaking.java, or jawbreaking.py
Author: Juan Camilo Corena
The Advanced Cutting Machines (ACM) has developed a new product for cutting rectangular candies into shorter
pieces. The width of candies has been optimized already, so this machine’s purpose is about optimizing the
length of cuts. ACM is very excited about the new machine because it will solve the eternal discussion of how
long candies should be for a given audience.
The in-house Mathematics Department of ACM determined how the machine cuts the pieces of candy. The
lengths of candy that the machine can cut are those shorter than original one L and can be represented as a
fraction of the form a·L
b , where integers a and b have to satisfy 0 <a and 0 <b ≤n. Here n represents a cutting
resolution for the different models of machine that will be produced; more expensive models will have higher
cutting resolution. For example, assume Alice wishes to buy a piece of candy of length at least 320 units. If this
piece were to be cut from a longer piece of 500 units of length and the cutting machine can only cut fractions of
the candy with a denominator at most b =3, then the following lengths of candy could be cut:
500
3 ,500
2 ,500
1 ,1000
3 ,1000
2 ,1000
1 ,1500
3 ,1500
2 ,1500
1 ,...
The in-house Mathematics Department predicts that, from these options, Alice would prefer the one with length1000
3 because it is the smallest one that is at least 320, as she wished, and will have less calories.
Given L, n, and a desired length of candy to cut d, compute the shortest candy length that the machine can cut
that is at least d units of length presented in the form of a reduced fraction (i.e., the numerator and denominator
cannot share positive factors other than 1).
Input
The input consists of several test cases, one per line. Each line contains integers 0 <L <106, 0 <n ≤5 000, and
0 <d ≤ L separated by a single space. The input ends with a line containing three blank-separated zeroes.
The input must be read from standard input.
Output
For each test case, output the shortest length that can be cut by the machine and that is at least d units of length
in the form of a reduced fraction.
The output must be written to standard output.
Sample Input
500 3 320
100 5 23
0 0 0
Sample Output
1000/3
25/1

-----------------------------------------------------------------------------------------------------------------------------

UVA13303

2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 19
K: kewl Texting Source file name: kewl.c, kewl.cpp, kewl.java, or kewl.py
Author: Ana Echavarría
Alicia and Roberto are good friends and often text each other. They would like to speed up their texting by
designing a mechanism that suggests what word they may want to text next. That way, they can select the
suggested word instead of having to type it directly, saving some time.
Being computer science students who just learned about language models, they came up with a solution. For
each occurring word w in their past text messages, they have selected a word w′ as the suggestion to be shown
after typing w. The criteria for selecting w′ are the following:
• The word w′ is the word that comes after w the most times in the past text messages.
• If two or more words come after w the same number of times in the past texts, then w′ is the word among
them that appeared the most times overall in the past texts.
• If again, two or more words appeared the same number of times in the past texts, then w′ is the first one of
them in lexicographical order.
• They also want to suggest words that start or end a text message. Therefore, the start and end of texts (called
here {start}and {end}, respectively) are also considered words. When they sort words lexicographically,
{start}would come before {end}and they would both come before any other word in the texts.
For example, consider the following text messages (one per line):
1. what a nice day
2. this is the nice restaurant he talked about
3. we want nice weather and hope it is a nice day
There are three words that follow the word nice, namely, day, weather, and restaurant. However, day
comes after nice 2 times, while restaurant and weather do so only once. Based on their model, the word
suggested after typing nice is the word day. Similarly, the word is is followed once by both a and the, but a is
more frequent in the texts overall (it appears 2 times while the appears only once); therefore, the suggestion for
is is the word a. The suggestion for day is {end}since, in most cases, it is used to end a text. On the other hand,
the words what, this, and we all come at the start of sentences and they all appear only once in the texts: hence,
this (the first one in lexicographical order of the three) is the suggestion for {start}, i.e., for the beginning of a
text message.
Alicia and Roberto would like to know what the sentence generated by always picking the word suggested by
their language model would be. Note that such a text message either ends after a finite number of suggestions or
never ends. For the example above, the sentence resulting by always picking the model’s suggestion is
this is a nice day
This is because the suggested starting word is this, the word suggested after this is is and so on, until the
word day is reached (whose suggestion is {end}, that is, the end of the text).
Your task is, for a given history of text messages between Alicia and Roberto, to compute the sentence generated
by always picking the word suggested by the language model or identify if such a process never terminates.
2018 ACIS REDIS - XXXII Colombian Programming Contest - ACM ICPC 20
Input
The input consist of several test cases. Each test case begins with a line containing a single integer n defining the
number of text messages. Each of the next n lines represents a text message containing at least one word. Every
word in the input consists only of lowercase English letters. There is no limit on the number of text messages.
However, the entire set of text messages has at most 105 words in total and each word will have at most 20
characters.
The input must be read from standard input.
Output
For each test case, output a single line containing the sentence that would result by always selecting the word
suggested by the language model or INFINITE if this method would result in an infinite text message. Use a
single blank to separate each pair of consecutive words in the output.
The output must be written to standard output.
Sample Input
3
what a nice day
this is the nice restaurant he talked about
we want nice weather and hope it is a nice day
3
a rabbit is white
the house is big and tall
we have a big house with a door
1
a rose is a rose
Sample Output
this is a nice day
INFINITE
a rose

-----------------------------------------------------------------------------------------------------------------------------