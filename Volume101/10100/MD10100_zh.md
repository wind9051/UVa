### 🌏 **Language**
| zh [中文](MD10100_zh.md) | en [English](md10100_en.md) | 
| [C++](UVa10100.cpp) |


<aside>

## **UVa 10100 - Longest Match**

一家新開張的偵探機構正在努力利用有限的情報來找出其偵探之間秘密信息傳遞的技術。由於他們在這個行業中是新手，他們非常清楚自己的消息很容易被其他團體截獲並修改。他們希望通過檢查消息中被更改的部分來猜測其他團體的意圖。首先，他們需要找出最長匹配的長度。你的任務是幫助他們完成這項工作。

---

### **輸入**

輸入文件可能包含多個測試案例。每個測試案例由兩行字符串組成。

- 字符串中可能包含空行和非字母的可打印標點符號字符。
- 每行字符串的長度不超過 1000 個字符。
- 每個單詞的長度小於 20 個字符。

### **輸出**

對於每個輸入測試案例，輸出一行，格式如下：

1. 行首為測試案例的編號，右對齊，寬度為 2。
2. 如果兩行中至少有一行是空行，輸出 `Blank!`。
3. 否則，輸出兩行字符串的最長匹配長度，格式為 `Length of longest match: X`，其中 ( X ) 是最長匹配的長度。

---

</aside>

### **解法**

<aside>

> [!TIP]
>
> 1. **拆分字符串：**
>    - 將兩個字符串中的字母和數字提取出來
> 
> 2. **動態規劃：**
>    - 計算兩個單詞序列的 LCS 長度。
>    - 創建一個二維陣列 `LCS[i][j]`，其中 `i` 和 `j` 分別表示 `st1` 和 `st2` 的前 `i` 和 `j` 個單詞。
>    - 如果 `st1[i-1] == st2[j-1]`，則 `LCS[i][j] = LCS[i-1][j-1] + 1`。
>    - 否則，取 `LCS[i][j] = max(LCS[i][j-1], LCS[i-1][j])`。
> 
> 3. **結果輸出：**
>    - 如果任一字符串為空，則輸出 `"Blank!"`。
>    - 否則輸出 `"Length of longest match: x"`，其中 `x` 是 LCS 的長度。
> 

</aside>